/********************************************************************************
 *  Orgel.c
 *    オルゴール（電子工作教室）
 *
 *    Auther kawamura
 *    Date   2024/5/17
 *    Device PIC12F683
 *    Tool   xc8 v1.32
 *
 ********************************************************************************/

/*
						PIC12F683
					 ____    ____
					|    |__|    |
					|            |
	(+3[v])Vdd  | 1        8 |  Vss(GND)
			 GP5  | 2        7 |  GP0(10k VR)
			 GP4  | 3        6 |  GP1(TACT SW)
			 GP3  | 4        5 |  GP2(BUZZER)CCP1
					|            |
					|____________|

*/

/********************************************************************************
	ヘッダーファイル
 ********************************************************************************/
#include <htc.h>

#define SW GP1 // タクトスイッチ
#define BZ GP2 // ブザー

#define ON 0
#define OFF 1

// クロック周波数の定義
#define _XTAL_FREQ 8000000

/********************************************************************************
	プロトタイプ宣言
 ********************************************************************************/
void init_io(void);			// I/Oポートの初期化を行う関数
void init_ccp(void);			// CCPモジュールの初期化を行う関数
void init_tmr0(void);		// タイマ0の初期化を行う関数
void MelodyDataRead(void); // メロディデータの読み込み

/********************************************************************************
	コンフィグ
 ********************************************************************************/
__CONFIG(INTIO &WDTDIS & PWRTEN & MCLRDIS & BORDIS & UNPROTECT);

/********************************************************************************
	グローバル変数
 ********************************************************************************/
int tempo = 80;
int onpu = 4; // 2(2分音符)、4(4分音符)、8(8分音符)、16(16分音符)

// 曲データ
//----------  「音階チェック」の曲データ  ----------

// const unsigned char melody[] = {   1, 3, 5, 6, 8,10,12, //ドレミファソラシ
//                                   13,15,17,18,20,22,24, //ドレミファソラシ
//                                   25,27,29,30,32,34,36, //ドレミファソラシ
//                                   37,39,41,42,44,46,48, //ドレミファソラシ
//                                   99};

//----------  「チューリップ」の曲データ  ----------

// const unsigned char melody[] = {104,
// 										  1, 3, 5, 5, 1, 3, 5, 5,	 // ドレミー　ドレミー
// 										  8, 5, 3, 1, 3, 5, 3, 3,	 // ソミレド　レミレー
// 										  1, 3, 5, 5, 1, 3, 5, 5,	 // ドレミー　ドレミー
// 										  8, 5, 3, 1, 3, 5, 1, 1,	 // ソミレド　レミドー
// 										  8, 8, 5, 8, 10, 10, 8, 8, // ソソミソ　ララソー
// 										  5, 5, 3, 3, 1, 1, 1, 1,	 // ミミレレドーーー
// 										  99};

//----------  「かえるのうた」の曲データ  ----------

// const unsigned char melody[] = { 104,			//４分音符
//                                  1, 3, 5, 6, 5, 3, 1, 0,//ドレミファミレド
//                                  5, 6, 8, 10, 8, 6, 5, 0, 	              	//ミファソラソフェミ
//                                  1, 0, 1, 0, 1, 0, 1, 0,       	       	//ド＿ド＿ド＿ド＿
//                                  116,			//１６分音符
//                                  1, 0, 1, 0, 3, 0, 3, 0, 5, 0, 5, 0, 6, 0, 6, 0,	  	//ドドレレミミファファ
//                                  104,			//４分音符
//                                  5, 3, 1,                      	//ミレド
//                                  99};

// https://onlinesequencer.net/3995177
//----------  オリジナルの曲データ  ----------
const unsigned char melody[] = {
	 116,
	 24, 36, 35, 36, 31, 36, 29, 36, 28, 36, 26, 36, 28, 36, 29, 36,
	 24, 36, 35, 36, 31, 36, 29, 36, 28, 36, 26, 36, 28, 0, 29, 0,
	 24, 36, 35, 36, 31, 36, 29, 36, 28, 36, 26, 36, 28, 36, 29, 36,

	 // 4

	 24, 36, 35, 36,
	 108,
	 31, 29,
	 104,
	 29, 0,

	 108,
	 16, 0, 16, 0, 16, 0, 16, 19,
	 19, 0, 17, 16, 16, 0, 0, 7,

	 108,
	 16, 0, 16, 0, 16, 0,
	 116,
	 16, 0, 16, 17,

	 102,
	 17,
	 108,
	 17, 17, 17, 0,

	 // 9
	 108,
	 16, 0, 16, 0, 16, 0, 16, 19,

	 19, 0, 17, 16, 16, 0, 17, 19,

	 19,
	 102,
	 0,
	 116,
	 12, 12, 12, 14, 14, 12,

	 // 12
	 104,
	 12, 0, 0,
	 108,
	 0, 16,

	 116,
	 17, 0, 17, 0, 17, 0, 16, 17, 0,
	 104,
	 17,
	 108,
	 0, 16,

	 116,
	 17, 0, 17, 0, 17, 0, 16, 17, 17, 16, 16, 16,
	 108,
	 0, 12,

	 // 15
	 116,
	 14, 14, 12, 14, 14, 0, 14, 0, 14, 14, 12, 14, 14, 14, 16, 16,
	 102,
	 16, 0,

	 116,
	 0, 0, 18, 0, 18, 0, 20, 0, 20, 20, 16, 16, 16, 25, 0, 25,

	 // 18
	 104,
	 25, 0,
	 116,
	 25, 25, 26, 25, 25, 21, 0, 21,

	 104,
	 21,
	 116,
	 0, 0, 20, 21, 21, 21, 20, 21, 21, 25, 0, 25,

	 102,
	 25,
	 104,
	 25, 0,

	 // 21
	 116,
	 0, 0, 18, 0, 18, 0, 20, 0, 20, 20,
	 116,
	 16, 16, 16, 25, 0, 25,

	 104,
	 25, 0,
	 116,
	 25, 25, 26, 28, 28, 21, 28,

	 // カット

	 // 59
	 108,
	 28, 28, 28,
	 116,
	 26, 25, 25, 0, 26, 25,
	 104,
	 25,

	 102,
	 25,
	 104,
	 0, 22,

	 // 61
	 116,
	 23, 35, 34, 35, 28, 35, 26, 35, 25, 35, 23, 35, 25, 35, 26, 35,

	 23, 35, 34, 35, 28, 35, 26, 35,
	 104,
	 25, 22,

	 116,
	 23, 35, 34, 35, 28, 35, 26, 35, 25, 35, 23, 35, 25, 35, 26, 35,

	 23, 35, 34, 35,
	 108,
	 28, 26, 26, 28, 26, 26,

	 26, 40,
	 116,
	 40, 40, 40, 38,
	 102,
	 38,
	 99};

/********************************************************************************
	音階データ
 ********************************************************************************/
// 音階データはEEPROMに格納する。
// EEPROMは16進数を用いい、8バイト単位で格納する
__EEPROM_DATA(0x00, 0xEE, 0xE0, 0xD4, 0xC8, 0xBD, 0xB2, 0xA8);
__EEPROM_DATA(0x9F, 0x95, 0x8D, 0x85, 0x7E, 0x77, 0x6F, 0x69);
__EEPROM_DATA(0x63, 0x5E, 0x58, 0x53, 0x4F, 0x4A, 0x46, 0x42);
__EEPROM_DATA(0x3E, 0x3B, 0x37, 0x34, 0x31, 0x2E, 0x2C, 0x29);
__EEPROM_DATA(0x27, 0x25, 0x23, 0x21, 0x1F, 0x1D, 0x1B, 0x1A);
__EEPROM_DATA(0x18, 0x17, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10);
__EEPROM_DATA(0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);

unsigned char i;

int isrCnt = 0; // 割込みが発生した回数
bit EndFlg = 0; // 演奏が終了したら「1」になるフラグ

/********************************************************************************
	init_io関数
 ********************************************************************************/
void init_io(void)
{
	ANSEL = 0b00000000;	// AN0～AN2はデジタル入出力ピンとして使う
	CMCON0 = 0x07;			// コンパレータは使用しない
								//	ADCON0 = 0x00;       // A/Dコンバータは使用しない
	OSCCON = 0x70;			// 内蔵クロック8[MHz]を使う(111)
	TRISIO = 0b00000010; // GPIO1は入力、他は出力
	WPU = 0b00000010;		// GPIO1は内蔵プルアップを使う
								//	IOC    = 0b00100000; // GPIO5で入力レベル変化割込みを使う

	BZ = 0; // ブザーOFF
}

/********************************************************************************
	init_ccp関数
	  8[MHz]のクロックを使用する

	  (1)CCP1CON(CCP1 Control Register)
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  |    7    |    6    |    5    |    4    |    3    |     2    |    1     |     0    |
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  |   ---   |   ---   |  DC1B1  |  DC1B0  | CCP1M3  |  CCP1M2  |  CCP1M1  |  CCP1M0  |
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  | 未実装  | 未実装  |  DC1の下位2ﾋﾞｯﾄ   |   CCPﾓｼﾞｭｰﾙの動作(1100)でPWMﾓｰﾄﾞとなる   |
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  ※PWMモードとは？
			 PR2レジスタで指定する周期と、CCPR1Lレジスタで指定するパルス幅により、
			 CCP1ピンからパルス（矩形波）を出力するモード。
			 ┏━━━━┓　　　　┏━━━━┓
			 ┃　　　　┃　　　　┃　　　　┃
			 ┃　　　　┃　　　　┃　　　　┃
		  ━┛　　　　┗━━━━┛　　　　┗
		 　 |←ﾊﾟﾙｽ幅→|
		  　| (CCPR1L) |
			 |
			 |←   周期 (PR2)  →|

	  (2)T2CON(Timer2 Control Register)
		  タイマ2の動作を決めるレジスタ。
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  |    7    |    6    |    5    |    4    |    3    |     2    |    1     |    0     |
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  |   ---   | TOUTPS3 | TOUTPS2 | TOUTPS1 | TOUTPS0 |  TMR2ON  | T2CKPS1  | T2CKPS1  |
		  +---------+---------+---------+---------+---------+----------+----------+----------+
		  | 未実装  |        ﾀｲﾏ2出力ﾎﾟｽﾄｽｹｰﾗ(1～16)        | ﾀｲﾏ2動作 | ﾀｲﾏ2ﾌﾟﾘｽｹｰﾗ(1,4,16) |
		  +---------+---------+---------+---------+---------+----------+----------+----------+

	  (3)PR2(Timer2 Module Period Register)
		  8ビットのレジスタでPWMの周期を決めるレジスタ。TMR2レジスタと比較する。

	  (4)TMR2(Timer2 Register)
		  8ビットのレジスタ。クロック(Tosc)でカウントアップする。プリスケーラ(PS)で分周(1,4,16)できる。

	  (5)CCPR1L
		  PWMのパルス幅(DC:デューティサイクル)を決める8ビットのレジスタ。
		  CCP1CONレジスタのDC1B1ビットとDC1B0ビットの合計10ビットを使う。

クロック周波数=8[MHz]
PR2(周期)=199
CCPR1L=100
PS=16

命令サイクル(Tosc)=1/8[MHz]=0.125[us]

PWM周期=(PR2+1)*4*Tsoc*PS=
		=(199+1)*4*0.125[us]*16=1600[us]

PWMパルス幅=Tosc*PR2=0.125[us]*50=6.25[us]
PWMディーティー比=25対1=4対1


440[Hz](2272.73[us])から1760[Hz](568.18[us])までの周期を出力できるようにしたい

 ********************************************************************************/
void init_ccp(void)
{
	// CCPR1L = 1000; //PWMデューティーサイクルの設定

	CCP1CON = 0x0C; // PWMモード（アクティブハイ）に設定

	T2CON = 0x03; // TMR2=OFF、PS=16
}

/********************************************************************************
	init_tmr0関数
 ********************************************************************************/
/*
  内蔵8[MHz]のクロックを使用して、1[ms]の割り込みをつくる
  プリスケーラが8の場合のTMR0の割込み周期は、
	 1/8[MHz]*4*8*250=0.001[us]
							=1[ms]
	テンポは、1分間における拍の長さ。120のとき、0.5秒。
*/
void init_tmr0(void)
{
	OPTION_REG = 0b10000010; // システムクロック使用、プリスケーラ=1/8
	TMR0 = 6;					 // TMR0レジスタに6をセット（256-6=250回）
	T0IE = 0;					 // TMR0割込み不許可
	GIE = 0;						 // 全体割込み不許可
}

/********************************************************************************
	main関数
 ********************************************************************************/
void main(void)
{
	init_io();	 // I/Oポートの初期化
	init_ccp();	 // CCPモジュールの初期化
	init_tmr0(); // タイマ0の初期化

	while (1)
	{
		//----------  スタートスイッチの処理  ----------
		while (1)
		{
			if (SW == 0)
			{						 // 押したか？
				__delay_ms(10); // 10[ms]のウェイト
				while (SW == 0)
				{						 // 離れるまでループ
					__delay_ms(10); // 10[ms]のウェイト
				}
				break; // ループから抜ける
			}
		}

		i = 0;
		MelodyDataRead(); // メロディデータの読み込み（一件先読み）

		TMR2ON = 1; // タイマ２動作開始
		T0IE = 1;	// TMR0割込み許可
		GIE = 1;		// 全体割込み許可

		while (1)
		{

			//----------  割込み回数　次の音データを読み込む  ----------
			if (isrCnt >= 60 / (float)tempo * 1000 / (float)onpu * 4)
			{
				isrCnt = 0; // 割込み回数のゼロクリア
				i++;
				MelodyDataRead(); // メロディデータの読み込み
				if (EndFlg == 1)
				{ // フラグが「1」ならば、ループを抜け演奏終了
					break;
				}
			}

			//----------  ON/OFFスイッチの処理  ----------
			if (SW == 0)
			{						 // 押したか？
				__delay_ms(10); // 10[ms]のウェイト
				while (SW == 0)
				{						 // 離れるまでループ
					__delay_ms(10); // 10[ms]のウェイト
				}
				TMR2ON = ~TMR2ON; // タイマ２をON/OFF
			}
		}
		EndFlg = 0;
	}
}

/********************************************************************************
	MelodyDataRead関数  メロディデータの読み込み
 ********************************************************************************/
void MelodyDataRead(void) // メロディデータの読み込み
{
	char flg = 0; // 音符データ(ドレミなど)か演奏終了(99)を読み込んだら「1」になるフラグ

	while (1)
	{
		switch (melody[i])
		{
		case 102: // ２分音符
			onpu = 2;
			i++;
			break;
		case 104: // ４分音符
			onpu = 4;
			i++;
			break;
		case 108: // ８分音符
			onpu = 8;
			i++;
			break;
		case 116: // １６分音符
			onpu = 16;
			i++;
			break;
		case 132: // ３２分音符
			onpu = 32;
			i++;
			break;
		case 99:			// 演奏終了
			TMR2ON = 0; // タイマ2を停止
			T0IE = 0;	// TMR0割込み不許可
			GIE = 0;		// 全体割込み不許可
			EndFlg = 1;
			flg = 1;
			break;
		default:									// 音符データ
			PR2 = EEPROM_READ(melody[i]); // PWM周期の設定
			CCPR1L = PR2 / 2;					// PWMパルス幅の設定
			flg = 1;
			break;
		}

		if (flg == 1)
		{
			break; // ループを抜ける
		}
	}
}

/********************************************************************************
	割込み処理プログラム（タイマ0で1[ms]ごとに実行される）
 ********************************************************************************/
void interrupt timer0_isr(void)
{
	if (T0IF == 1)
	{
		T0IF = 0; // TMR0割込みフラグをゼロクリア
		TMR0 = 6; // TMR0レジスタに6をセット（256-6=250回）
	}
	isrCnt++; // 割込み回数のカウントアップ
}
